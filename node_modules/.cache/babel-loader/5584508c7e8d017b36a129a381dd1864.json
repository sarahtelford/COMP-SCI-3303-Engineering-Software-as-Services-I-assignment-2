{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * # Semantic UI - Transition\n * http://github.com/semantic-org/semantic-ui/\n *\n *\n * Released under the MIT license\n * http://opensource.org/licenses/MIT\n *\n */\n;\n\n(function ($, window, document, undefined) {\n  'use strict';\n\n  window = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\n  $.fn.transition = function () {\n    var $allModules = $(this),\n        moduleSelector = $allModules.selector || '',\n        time = new Date().getTime(),\n        performance = [],\n        moduleArguments = arguments,\n        query = moduleArguments[0],\n        queryArguments = [].slice.call(arguments, 1),\n        methodInvoked = typeof query === 'string',\n        requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n      setTimeout(callback, 0);\n    },\n        returnedValue;\n\n    $allModules.each(function (index) {\n      var $module = $(this),\n          element = this,\n          // set at run time\n      settings,\n          instance,\n          error,\n          className,\n          metadata,\n          animationEnd,\n          animationName,\n          namespace,\n          moduleNamespace,\n          eventNamespace,\n          module;\n      module = {\n        initialize: function initialize() {\n          // get full settings\n          settings = module.get.settings.apply(element, moduleArguments); // shorthand\n\n          className = settings.className;\n          error = settings.error;\n          metadata = settings.metadata; // define namespace\n\n          eventNamespace = '.' + settings.namespace;\n          moduleNamespace = 'module-' + settings.namespace;\n          instance = $module.data(moduleNamespace) || module; // get vendor specific events\n\n          animationEnd = module.get.animationEndEvent();\n\n          if (methodInvoked) {\n            methodInvoked = module.invoke(query);\n          } // method not invoked, lets run an animation\n\n\n          if (methodInvoked === false) {\n            module.verbose('Converted arguments into settings object', settings);\n\n            if (settings.interval) {\n              module.delay(settings.animate);\n            } else {\n              module.animate();\n            }\n\n            module.instantiate();\n          }\n        },\n        instantiate: function instantiate() {\n          module.verbose('Storing instance of module', module);\n          instance = module;\n          $module.data(moduleNamespace, instance);\n        },\n        destroy: function destroy() {\n          module.verbose('Destroying previous module for', element);\n          $module.removeData(moduleNamespace);\n        },\n        refresh: function refresh() {\n          module.verbose('Refreshing display type on next animation');\n          delete module.displayType;\n        },\n        forceRepaint: function forceRepaint() {\n          module.verbose('Forcing element repaint');\n          var $parentElement = $module.parent(),\n              $nextElement = $module.next();\n\n          if ($nextElement.length === 0) {\n            $module.detach().appendTo($parentElement);\n          } else {\n            $module.detach().insertBefore($nextElement);\n          }\n        },\n        repaint: function repaint() {\n          module.verbose('Repainting element');\n          var fakeAssignment = element.offsetWidth;\n        },\n        delay: function delay(interval) {\n          var direction = module.get.animationDirection(),\n              shouldReverse,\n              delay;\n\n          if (!direction) {\n            direction = module.can.transition() ? module.get.direction() : 'static';\n          }\n\n          interval = interval !== undefined ? interval : settings.interval;\n          shouldReverse = settings.reverse == 'auto' && direction == className.outward;\n          delay = shouldReverse || settings.reverse == true ? ($allModules.length - index) * settings.interval : index * settings.interval;\n          module.debug('Delaying animation by', delay);\n          setTimeout(module.animate, delay);\n        },\n        animate: function animate(overrideSettings) {\n          settings = overrideSettings || settings;\n\n          if (!module.is.supported()) {\n            module.error(error.support);\n            return false;\n          }\n\n          module.debug('Preparing animation', settings.animation);\n\n          if (module.is.animating()) {\n            if (settings.queue) {\n              if (!settings.allowRepeats && module.has.direction() && module.is.occurring() && module.queuing !== true) {\n                module.debug('Animation is currently occurring, preventing queueing same animation', settings.animation);\n              } else {\n                module.queue(settings.animation);\n              }\n\n              return false;\n            } else if (!settings.allowRepeats && module.is.occurring()) {\n              module.debug('Animation is already occurring, will not execute repeated animation', settings.animation);\n              return false;\n            } else {\n              module.debug('New animation started, completing previous early', settings.animation);\n              instance.complete();\n            }\n          }\n\n          if (module.can.animate()) {\n            module.set.animating(settings.animation);\n          } else {\n            module.error(error.noAnimation, settings.animation, element);\n          }\n        },\n        reset: function reset() {\n          module.debug('Resetting animation to beginning conditions');\n          module.remove.animationCallbacks();\n          module.restore.conditions();\n          module.remove.animating();\n        },\n        queue: function queue(animation) {\n          module.debug('Queueing animation of', animation);\n          module.queuing = true;\n          $module.one(animationEnd + '.queue' + eventNamespace, function () {\n            module.queuing = false;\n            module.repaint();\n            module.animate.apply(this, settings);\n          });\n        },\n        complete: function complete(event) {\n          module.debug('Animation complete', settings.animation);\n          module.remove.completeCallback();\n          module.remove.failSafe();\n\n          if (!module.is.looping()) {\n            if (module.is.outward()) {\n              module.verbose('Animation is outward, hiding element');\n              module.restore.conditions();\n              module.hide();\n            } else if (module.is.inward()) {\n              module.verbose('Animation is outward, showing element');\n              module.restore.conditions();\n              module.show();\n            } else {\n              module.verbose('Static animation completed');\n              module.restore.conditions();\n              settings.onComplete.call(element);\n            }\n          }\n        },\n        force: {\n          visible: function visible() {\n            var style = $module.attr('style'),\n                userStyle = module.get.userStyle(),\n                displayType = module.get.displayType(),\n                overrideStyle = userStyle + 'display: ' + displayType + ' !important;',\n                currentDisplay = $module.css('display'),\n                emptyStyle = style === undefined || style === '';\n\n            if (currentDisplay !== displayType) {\n              module.verbose('Overriding default display to show element', displayType);\n              $module.attr('style', overrideStyle);\n            } else if (emptyStyle) {\n              $module.removeAttr('style');\n            }\n          },\n          hidden: function hidden() {\n            var style = $module.attr('style'),\n                currentDisplay = $module.css('display'),\n                emptyStyle = style === undefined || style === '';\n\n            if (currentDisplay !== 'none' && !module.is.hidden()) {\n              module.verbose('Overriding default display to hide element');\n              $module.css('display', 'none');\n            } else if (emptyStyle) {\n              $module.removeAttr('style');\n            }\n          }\n        },\n        has: {\n          direction: function direction(animation) {\n            var hasDirection = false;\n            animation = animation || settings.animation;\n\n            if (typeof animation === 'string') {\n              animation = animation.split(' ');\n              $.each(animation, function (index, word) {\n                if (word === className.inward || word === className.outward) {\n                  hasDirection = true;\n                }\n              });\n            }\n\n            return hasDirection;\n          },\n          inlineDisplay: function inlineDisplay() {\n            var style = $module.attr('style') || '';\n            return $.isArray(style.match(/display.*?;/, ''));\n          }\n        },\n        set: {\n          animating: function animating(animation) {\n            var animationClass, direction; // remove previous callbacks\n\n            module.remove.completeCallback(); // determine exact animation\n\n            animation = animation || settings.animation;\n            animationClass = module.get.animationClass(animation); // save animation class in cache to restore class names\n\n            module.save.animation(animationClass); // override display if necessary so animation appears visibly\n\n            module.force.visible();\n            module.remove.hidden();\n            module.remove.direction();\n            module.start.animation(animationClass);\n          },\n          duration: function duration(animationName, _duration) {\n            _duration = _duration || settings.duration;\n            _duration = typeof _duration == 'number' ? _duration + 'ms' : _duration;\n\n            if (_duration || _duration === 0) {\n              module.verbose('Setting animation duration', _duration);\n              $module.css({\n                'animation-duration': _duration\n              });\n            }\n          },\n          direction: function direction(_direction) {\n            _direction = _direction || module.get.direction();\n\n            if (_direction == className.inward) {\n              module.set.inward();\n            } else {\n              module.set.outward();\n            }\n          },\n          looping: function looping() {\n            module.debug('Transition set to loop');\n            $module.addClass(className.looping);\n          },\n          hidden: function hidden() {\n            $module.addClass(className.transition).addClass(className.hidden);\n          },\n          inward: function inward() {\n            module.debug('Setting direction to inward');\n            $module.removeClass(className.outward).addClass(className.inward);\n          },\n          outward: function outward() {\n            module.debug('Setting direction to outward');\n            $module.removeClass(className.inward).addClass(className.outward);\n          },\n          visible: function visible() {\n            $module.addClass(className.transition).addClass(className.visible);\n          }\n        },\n        start: {\n          animation: function animation(animationClass) {\n            animationClass = animationClass || module.get.animationClass();\n            module.debug('Starting tween', animationClass);\n            $module.addClass(animationClass).one(animationEnd + '.complete' + eventNamespace, module.complete);\n\n            if (settings.useFailSafe) {\n              module.add.failSafe();\n            }\n\n            module.set.duration(settings.duration);\n            settings.onStart.call(element);\n          }\n        },\n        save: {\n          animation: function animation(_animation) {\n            if (!module.cache) {\n              module.cache = {};\n            }\n\n            module.cache.animation = _animation;\n          },\n          displayType: function displayType(_displayType) {\n            if (_displayType !== 'none') {\n              $module.data(metadata.displayType, _displayType);\n            }\n          },\n          transitionExists: function transitionExists(animation, exists) {\n            $.fn.transition.exists[animation] = exists;\n            module.verbose('Saving existence of transition', animation, exists);\n          }\n        },\n        restore: {\n          conditions: function conditions() {\n            var animation = module.get.currentAnimation();\n\n            if (animation) {\n              $module.removeClass(animation);\n              module.verbose('Removing animation class', module.cache);\n            }\n\n            module.remove.duration();\n          }\n        },\n        add: {\n          failSafe: function failSafe() {\n            var duration = module.get.duration();\n            module.timer = setTimeout(function () {\n              $module.triggerHandler(animationEnd);\n            }, duration + settings.failSafeDelay);\n            module.verbose('Adding fail safe timer', module.timer);\n          }\n        },\n        remove: {\n          animating: function animating() {\n            $module.removeClass(className.animating);\n          },\n          animationCallbacks: function animationCallbacks() {\n            module.remove.queueCallback();\n            module.remove.completeCallback();\n          },\n          queueCallback: function queueCallback() {\n            $module.off('.queue' + eventNamespace);\n          },\n          completeCallback: function completeCallback() {\n            $module.off('.complete' + eventNamespace);\n          },\n          display: function display() {\n            $module.css('display', '');\n          },\n          direction: function direction() {\n            $module.removeClass(className.inward).removeClass(className.outward);\n          },\n          duration: function duration() {\n            $module.css('animation-duration', '');\n          },\n          failSafe: function failSafe() {\n            module.verbose('Removing fail safe timer', module.timer);\n\n            if (module.timer) {\n              clearTimeout(module.timer);\n            }\n          },\n          hidden: function hidden() {\n            $module.removeClass(className.hidden);\n          },\n          visible: function visible() {\n            $module.removeClass(className.visible);\n          },\n          looping: function looping() {\n            module.debug('Transitions are no longer looping');\n\n            if (module.is.looping()) {\n              module.reset();\n              $module.removeClass(className.looping);\n            }\n          },\n          transition: function transition() {\n            $module.removeClass(className.visible).removeClass(className.hidden);\n          }\n        },\n        get: {\n          settings: function settings(animation, duration, onComplete) {\n            // single settings object\n            if (_typeof(animation) == 'object') {\n              return $.extend(true, {}, $.fn.transition.settings, animation);\n            } // all arguments provided\n            else if (typeof onComplete == 'function') {\n                return $.extend({}, $.fn.transition.settings, {\n                  animation: animation,\n                  onComplete: onComplete,\n                  duration: duration\n                });\n              } // only duration provided\n              else if (typeof duration == 'string' || typeof duration == 'number') {\n                  return $.extend({}, $.fn.transition.settings, {\n                    animation: animation,\n                    duration: duration\n                  });\n                } // duration is actually settings object\n                else if (_typeof(duration) == 'object') {\n                    return $.extend({}, $.fn.transition.settings, duration, {\n                      animation: animation\n                    });\n                  } // duration is actually callback\n                  else if (typeof duration == 'function') {\n                      return $.extend({}, $.fn.transition.settings, {\n                        animation: animation,\n                        onComplete: duration\n                      });\n                    } // only animation provided\n                    else {\n                        return $.extend({}, $.fn.transition.settings, {\n                          animation: animation\n                        });\n                      }\n          },\n          animationClass: function animationClass(animation) {\n            var animationClass = animation || settings.animation,\n                directionClass = module.can.transition() && !module.has.direction() ? module.get.direction() + ' ' : '';\n            return className.animating + ' ' + className.transition + ' ' + directionClass + animationClass;\n          },\n          currentAnimation: function currentAnimation() {\n            return module.cache && module.cache.animation !== undefined ? module.cache.animation : false;\n          },\n          currentDirection: function currentDirection() {\n            return module.is.inward() ? className.inward : className.outward;\n          },\n          direction: function direction() {\n            return module.is.hidden() || !module.is.visible() ? className.inward : className.outward;\n          },\n          animationDirection: function animationDirection(animation) {\n            var direction;\n            animation = animation || settings.animation;\n\n            if (typeof animation === 'string') {\n              animation = animation.split(' '); // search animation name for out/in class\n\n              $.each(animation, function (index, word) {\n                if (word === className.inward) {\n                  direction = className.inward;\n                } else if (word === className.outward) {\n                  direction = className.outward;\n                }\n              });\n            } // return found direction\n\n\n            if (direction) {\n              return direction;\n            }\n\n            return false;\n          },\n          duration: function duration(_duration2) {\n            _duration2 = _duration2 || settings.duration;\n\n            if (_duration2 === false) {\n              _duration2 = $module.css('animation-duration') || 0;\n            }\n\n            return typeof _duration2 === 'string' ? _duration2.indexOf('ms') > -1 ? parseFloat(_duration2) : parseFloat(_duration2) * 1000 : _duration2;\n          },\n          displayType: function displayType(shouldDetermine) {\n            shouldDetermine = shouldDetermine !== undefined ? shouldDetermine : true;\n\n            if (settings.displayType) {\n              return settings.displayType;\n            }\n\n            if (shouldDetermine && $module.data(metadata.displayType) === undefined) {\n              // create fake element to determine display state\n              module.can.transition(true);\n            }\n\n            return $module.data(metadata.displayType);\n          },\n          userStyle: function userStyle(style) {\n            style = style || $module.attr('style') || '';\n            return style.replace(/display.*?;/, '');\n          },\n          transitionExists: function transitionExists(animation) {\n            return $.fn.transition.exists[animation];\n          },\n          animationStartEvent: function animationStartEvent() {\n            var element = document.createElement('div'),\n                animations = {\n              'animation': 'animationstart',\n              'OAnimation': 'oAnimationStart',\n              'MozAnimation': 'mozAnimationStart',\n              'WebkitAnimation': 'webkitAnimationStart'\n            },\n                animation;\n\n            for (animation in animations) {\n              if (element.style[animation] !== undefined) {\n                return animations[animation];\n              }\n            }\n\n            return false;\n          },\n          animationEndEvent: function animationEndEvent() {\n            var element = document.createElement('div'),\n                animations = {\n              'animation': 'animationend',\n              'OAnimation': 'oAnimationEnd',\n              'MozAnimation': 'mozAnimationEnd',\n              'WebkitAnimation': 'webkitAnimationEnd'\n            },\n                animation;\n\n            for (animation in animations) {\n              if (element.style[animation] !== undefined) {\n                return animations[animation];\n              }\n            }\n\n            return false;\n          }\n        },\n        can: {\n          transition: function transition(forced) {\n            var animation = settings.animation,\n                transitionExists = module.get.transitionExists(animation),\n                displayType = module.get.displayType(false),\n                elementClass,\n                tagName,\n                $clone,\n                currentAnimation,\n                inAnimation,\n                directionExists;\n\n            if (transitionExists === undefined || forced) {\n              module.verbose('Determining whether animation exists');\n              elementClass = $module.attr('class');\n              tagName = $module.prop('tagName');\n              $clone = $('<' + tagName + ' />').addClass(elementClass).insertAfter($module);\n              currentAnimation = $clone.addClass(animation).removeClass(className.inward).removeClass(className.outward).addClass(className.animating).addClass(className.transition).css('animationName');\n              inAnimation = $clone.addClass(className.inward).css('animationName');\n\n              if (!displayType) {\n                displayType = $clone.attr('class', elementClass).removeAttr('style').removeClass(className.hidden).removeClass(className.visible).show().css('display');\n                module.verbose('Determining final display state', displayType);\n                module.save.displayType(displayType);\n              }\n\n              $clone.remove();\n\n              if (currentAnimation != inAnimation) {\n                module.debug('Direction exists for animation', animation);\n                directionExists = true;\n              } else if (currentAnimation == 'none' || !currentAnimation) {\n                module.debug('No animation defined in css', animation);\n                return;\n              } else {\n                module.debug('Static animation found', animation, displayType);\n                directionExists = false;\n              }\n\n              module.save.transitionExists(animation, directionExists);\n            }\n\n            return transitionExists !== undefined ? transitionExists : directionExists;\n          },\n          animate: function animate() {\n            // can transition does not return a value if animation does not exist\n            return module.can.transition() !== undefined;\n          }\n        },\n        is: {\n          animating: function animating() {\n            return $module.hasClass(className.animating);\n          },\n          inward: function inward() {\n            return $module.hasClass(className.inward);\n          },\n          outward: function outward() {\n            return $module.hasClass(className.outward);\n          },\n          looping: function looping() {\n            return $module.hasClass(className.looping);\n          },\n          occurring: function occurring(animation) {\n            animation = animation || settings.animation;\n            animation = '.' + animation.replace(' ', '.');\n            return $module.filter(animation).length > 0;\n          },\n          visible: function visible() {\n            return $module.is(':visible');\n          },\n          hidden: function hidden() {\n            return $module.css('visibility') === 'hidden';\n          },\n          supported: function supported() {\n            return animationEnd !== false;\n          }\n        },\n        hide: function hide() {\n          module.verbose('Hiding element');\n\n          if (module.is.animating()) {\n            module.reset();\n          }\n\n          element.blur(); // IE will trigger focus change if element is not blurred before hiding\n\n          module.remove.display();\n          module.remove.visible();\n          module.set.hidden();\n          module.force.hidden();\n          settings.onHide.call(element);\n          settings.onComplete.call(element); // module.repaint();\n        },\n        show: function show(display) {\n          module.verbose('Showing element', display);\n          module.remove.hidden();\n          module.set.visible();\n          module.force.visible();\n          settings.onShow.call(element);\n          settings.onComplete.call(element); // module.repaint();\n        },\n        toggle: function toggle() {\n          if (module.is.visible()) {\n            module.hide();\n          } else {\n            module.show();\n          }\n        },\n        stop: function stop() {\n          module.debug('Stopping current animation');\n          $module.triggerHandler(animationEnd);\n        },\n        stopAll: function stopAll() {\n          module.debug('Stopping all animation');\n          module.remove.queueCallback();\n          $module.triggerHandler(animationEnd);\n        },\n        clear: {\n          queue: function queue() {\n            module.debug('Clearing animation queue');\n            module.remove.queueCallback();\n          }\n        },\n        enable: function enable() {\n          module.verbose('Starting animation');\n          $module.removeClass(className.disabled);\n        },\n        disable: function disable() {\n          module.debug('Stopping animation');\n          $module.addClass(className.disabled);\n        },\n        setting: function setting(name, value) {\n          module.debug('Changing setting', name, value);\n\n          if ($.isPlainObject(name)) {\n            $.extend(true, settings, name);\n          } else if (value !== undefined) {\n            if ($.isPlainObject(settings[name])) {\n              $.extend(true, settings[name], value);\n            } else {\n              settings[name] = value;\n            }\n          } else {\n            return settings[name];\n          }\n        },\n        internal: function internal(name, value) {\n          if ($.isPlainObject(name)) {\n            $.extend(true, module, name);\n          } else if (value !== undefined) {\n            module[name] = value;\n          } else {\n            return module[name];\n          }\n        },\n        debug: function debug() {\n          if (!settings.silent && settings.debug) {\n            if (settings.performance) {\n              module.performance.log(arguments);\n            } else {\n              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');\n              module.debug.apply(console, arguments);\n            }\n          }\n        },\n        verbose: function verbose() {\n          if (!settings.silent && settings.verbose && settings.debug) {\n            if (settings.performance) {\n              module.performance.log(arguments);\n            } else {\n              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');\n              module.verbose.apply(console, arguments);\n            }\n          }\n        },\n        error: function error() {\n          if (!settings.silent) {\n            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');\n            module.error.apply(console, arguments);\n          }\n        },\n        performance: {\n          log: function log(message) {\n            var currentTime, executionTime, previousTime;\n\n            if (settings.performance) {\n              currentTime = new Date().getTime();\n              previousTime = time || currentTime;\n              executionTime = currentTime - previousTime;\n              time = currentTime;\n              performance.push({\n                'Name': message[0],\n                'Arguments': [].slice.call(message, 1) || '',\n                'Element': element,\n                'Execution Time': executionTime\n              });\n            }\n\n            clearTimeout(module.performance.timer);\n            module.performance.timer = setTimeout(module.performance.display, 500);\n          },\n          display: function display() {\n            var title = settings.name + ':',\n                totalTime = 0;\n            time = false;\n            clearTimeout(module.performance.timer);\n            $.each(performance, function (index, data) {\n              totalTime += data['Execution Time'];\n            });\n            title += ' ' + totalTime + 'ms';\n\n            if (moduleSelector) {\n              title += ' \\'' + moduleSelector + '\\'';\n            }\n\n            if ($allModules.length > 1) {\n              title += ' ' + '(' + $allModules.length + ')';\n            }\n\n            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {\n              console.groupCollapsed(title);\n\n              if (console.table) {\n                console.table(performance);\n              } else {\n                $.each(performance, function (index, data) {\n                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');\n                });\n              }\n\n              console.groupEnd();\n            }\n\n            performance = [];\n          }\n        },\n        // modified for transition to return invoke success\n        invoke: function invoke(query, passedArguments, context) {\n          var object = instance,\n              maxDepth,\n              found,\n              response;\n          passedArguments = passedArguments || queryArguments;\n          context = element || context;\n\n          if (typeof query == 'string' && object !== undefined) {\n            query = query.split(/[\\. ]/);\n            maxDepth = query.length - 1;\n            $.each(query, function (depth, value) {\n              var camelCaseValue = depth != maxDepth ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;\n\n              if ($.isPlainObject(object[camelCaseValue]) && depth != maxDepth) {\n                object = object[camelCaseValue];\n              } else if (object[camelCaseValue] !== undefined) {\n                found = object[camelCaseValue];\n                return false;\n              } else if ($.isPlainObject(object[value]) && depth != maxDepth) {\n                object = object[value];\n              } else if (object[value] !== undefined) {\n                found = object[value];\n                return false;\n              } else {\n                return false;\n              }\n            });\n          }\n\n          if ($.isFunction(found)) {\n            response = found.apply(context, passedArguments);\n          } else if (found !== undefined) {\n            response = found;\n          }\n\n          if ($.isArray(returnedValue)) {\n            returnedValue.push(response);\n          } else if (returnedValue !== undefined) {\n            returnedValue = [returnedValue, response];\n          } else if (response !== undefined) {\n            returnedValue = response;\n          }\n\n          return found !== undefined ? found : false;\n        }\n      };\n      module.initialize();\n    });\n    return returnedValue !== undefined ? returnedValue : this;\n  }; // Records if CSS transition is available\n\n\n  $.fn.transition.exists = {};\n  $.fn.transition.settings = {\n    // module info\n    name: 'Transition',\n    // hide all output from this component regardless of other settings\n    silent: false,\n    // debug content outputted to console\n    debug: false,\n    // verbose debug output\n    verbose: false,\n    // performance data output\n    performance: true,\n    // event namespace\n    namespace: 'transition',\n    // delay between animations in group\n    interval: 0,\n    // whether group animations should be reversed\n    reverse: 'auto',\n    // animation callback event\n    onStart: function onStart() {},\n    onComplete: function onComplete() {},\n    onShow: function onShow() {},\n    onHide: function onHide() {},\n    // whether timeout should be used to ensure callback fires in cases animationend does not\n    useFailSafe: true,\n    // delay in ms for fail safe\n    failSafeDelay: 100,\n    // whether EXACT animation can occur twice in a row\n    allowRepeats: false,\n    // Override final display type on visible\n    displayType: false,\n    // animation duration\n    animation: 'fade',\n    duration: false,\n    // new animations will occur after previous ones\n    queue: true,\n    metadata: {\n      displayType: 'display'\n    },\n    className: {\n      animating: 'animating',\n      disabled: 'disabled',\n      hidden: 'hidden',\n      inward: 'in',\n      loading: 'loading',\n      looping: 'looping',\n      outward: 'out',\n      transition: 'transition',\n      visible: 'visible'\n    },\n    // possible errors\n    error: {\n      noAnimation: 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.',\n      repeated: 'That animation is already occurring, cancelling repeated animation',\n      method: 'The method you called is not defined',\n      support: 'This browser does not support CSS animations'\n    }\n  };\n})(jQuery, window, document);","map":null,"metadata":{},"sourceType":"module"}