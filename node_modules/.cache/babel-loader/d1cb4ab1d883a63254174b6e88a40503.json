{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * # Semantic UI - Popup\n * http://github.com/semantic-org/semantic-ui/\n *\n *\n * Released under the MIT license\n * http://opensource.org/licenses/MIT\n *\n */\n;\n\n(function ($, window, document, undefined) {\n  'use strict';\n\n  window = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\n  $.fn.popup = function (parameters) {\n    var $allModules = $(this),\n        $document = $(document),\n        $window = $(window),\n        $body = $('body'),\n        moduleSelector = $allModules.selector || '',\n        hasTouch = true,\n        time = new Date().getTime(),\n        performance = [],\n        query = arguments[0],\n        methodInvoked = typeof query == 'string',\n        queryArguments = [].slice.call(arguments, 1),\n        returnedValue;\n    $allModules.each(function () {\n      var settings = $.isPlainObject(parameters) ? $.extend(true, {}, $.fn.popup.settings, parameters) : $.extend({}, $.fn.popup.settings),\n          selector = settings.selector,\n          className = settings.className,\n          error = settings.error,\n          metadata = settings.metadata,\n          namespace = settings.namespace,\n          eventNamespace = '.' + settings.namespace,\n          moduleNamespace = 'module-' + namespace,\n          $module = $(this),\n          $context = $(settings.context),\n          $scrollContext = $(settings.scrollContext),\n          $boundary = $(settings.boundary),\n          $target = settings.target ? $(settings.target) : $module,\n          $popup,\n          $offsetParent,\n          searchDepth = 0,\n          triedPositions = false,\n          openedWithTouch = false,\n          element = this,\n          instance = $module.data(moduleNamespace),\n          documentObserver,\n          elementNamespace,\n          _id,\n          module;\n\n      module = {\n        // binds events\n        initialize: function initialize() {\n          module.debug('Initializing', $module);\n          module.createID();\n          module.bind.events();\n\n          if (!module.exists() && settings.preserve) {\n            module.create();\n          }\n\n          if (settings.observeChanges) {\n            module.observeChanges();\n          }\n\n          module.instantiate();\n        },\n        instantiate: function instantiate() {\n          module.verbose('Storing instance', module);\n          instance = module;\n          $module.data(moduleNamespace, instance);\n        },\n        observeChanges: function observeChanges() {\n          if ('MutationObserver' in window) {\n            documentObserver = new MutationObserver(module.event.documentChanged);\n            documentObserver.observe(document, {\n              childList: true,\n              subtree: true\n            });\n            module.debug('Setting up mutation observer', documentObserver);\n          }\n        },\n        refresh: function refresh() {\n          if (settings.popup) {\n            $popup = $(settings.popup).eq(0);\n          } else {\n            if (settings.inline) {\n              $popup = $target.nextAll(selector.popup).eq(0);\n              settings.popup = $popup;\n            }\n          }\n\n          if (settings.popup) {\n            $popup.addClass(className.loading);\n            $offsetParent = module.get.offsetParent();\n            $popup.removeClass(className.loading);\n\n            if (settings.movePopup && module.has.popup() && module.get.offsetParent($popup)[0] !== $offsetParent[0]) {\n              module.debug('Moving popup to the same offset parent as target');\n              $popup.detach().appendTo($offsetParent);\n            }\n          } else {\n            $offsetParent = settings.inline ? module.get.offsetParent($target) : module.has.popup() ? module.get.offsetParent($popup) : $body;\n          }\n\n          if ($offsetParent.is('html') && $offsetParent[0] !== $body[0]) {\n            module.debug('Setting page as offset parent');\n            $offsetParent = $body;\n          }\n\n          if (module.get.variation()) {\n            module.set.variation();\n          }\n        },\n        reposition: function reposition() {\n          module.refresh();\n          module.set.position();\n        },\n        destroy: function destroy() {\n          module.debug('Destroying previous module');\n\n          if (documentObserver) {\n            documentObserver.disconnect();\n          } // remove element only if was created dynamically\n\n\n          if ($popup && !settings.preserve) {\n            module.removePopup();\n          } // clear all timeouts\n\n\n          clearTimeout(module.hideTimer);\n          clearTimeout(module.showTimer); // remove events\n\n          module.unbind.close();\n          module.unbind.events();\n          $module.removeData(moduleNamespace);\n        },\n        event: {\n          start: function start(event) {\n            var delay = $.isPlainObject(settings.delay) ? settings.delay.show : settings.delay;\n            clearTimeout(module.hideTimer);\n\n            if (!openedWithTouch) {\n              module.showTimer = setTimeout(module.show, delay);\n            }\n          },\n          end: function end() {\n            var delay = $.isPlainObject(settings.delay) ? settings.delay.hide : settings.delay;\n            clearTimeout(module.showTimer);\n            module.hideTimer = setTimeout(module.hide, delay);\n          },\n          touchstart: function touchstart(event) {\n            openedWithTouch = true;\n            module.show();\n          },\n          resize: function resize() {\n            if (module.is.visible()) {\n              module.set.position();\n            }\n          },\n          documentChanged: function documentChanged(mutations) {\n            [].forEach.call(mutations, function (mutation) {\n              if (mutation.removedNodes) {\n                [].forEach.call(mutation.removedNodes, function (node) {\n                  if (node == element || $(node).find(element).length > 0) {\n                    module.debug('Element removed from DOM, tearing down events');\n                    module.destroy();\n                  }\n                });\n              }\n            });\n          },\n          hideGracefully: function hideGracefully(event) {\n            var $target = $(event.target),\n                isInDOM = $.contains(document.documentElement, event.target),\n                inPopup = $target.closest(selector.popup).length > 0; // don't close on clicks inside popup\n\n            if (event && !inPopup && isInDOM) {\n              module.debug('Click occurred outside popup hiding popup');\n              module.hide();\n            } else {\n              module.debug('Click was inside popup, keeping popup open');\n            }\n          }\n        },\n        // generates popup html from metadata\n        create: function create() {\n          var html = module.get.html(),\n              title = module.get.title(),\n              content = module.get.content();\n\n          if (html || content || title) {\n            module.debug('Creating pop-up html');\n\n            if (!html) {\n              html = settings.templates.popup({\n                title: title,\n                content: content\n              });\n            }\n\n            $popup = $('<div/>').addClass(className.popup).data(metadata.activator, $module).html(html);\n\n            if (settings.inline) {\n              module.verbose('Inserting popup element inline', $popup);\n              $popup.insertAfter($module);\n            } else {\n              module.verbose('Appending popup element to body', $popup);\n              $popup.appendTo($context);\n            }\n\n            module.refresh();\n            module.set.variation();\n\n            if (settings.hoverable) {\n              module.bind.popup();\n            }\n\n            settings.onCreate.call($popup, element);\n          } else if ($target.next(selector.popup).length !== 0) {\n            module.verbose('Pre-existing popup found');\n            settings.inline = true;\n            settings.popup = $target.next(selector.popup).data(metadata.activator, $module);\n            module.refresh();\n\n            if (settings.hoverable) {\n              module.bind.popup();\n            }\n          } else if (settings.popup) {\n            $(settings.popup).data(metadata.activator, $module);\n            module.verbose('Used popup specified in settings');\n            module.refresh();\n\n            if (settings.hoverable) {\n              module.bind.popup();\n            }\n          } else {\n            module.debug('No content specified skipping display', element);\n          }\n        },\n        createID: function createID() {\n          _id = (Math.random().toString(16) + '000000000').substr(2, 8);\n          elementNamespace = '.' + _id;\n          module.verbose('Creating unique id for element', _id);\n        },\n        // determines popup state\n        toggle: function toggle() {\n          module.debug('Toggling pop-up');\n\n          if (module.is.hidden()) {\n            module.debug('Popup is hidden, showing pop-up');\n            module.unbind.close();\n            module.show();\n          } else {\n            module.debug('Popup is visible, hiding pop-up');\n            module.hide();\n          }\n        },\n        show: function show(callback) {\n          callback = callback || function () {};\n\n          module.debug('Showing pop-up', settings.transition);\n\n          if (module.is.hidden() && !(module.is.active() && module.is.dropdown())) {\n            if (!module.exists()) {\n              module.create();\n            }\n\n            if (settings.onShow.call($popup, element) === false) {\n              module.debug('onShow callback returned false, cancelling popup animation');\n              return;\n            } else if (!settings.preserve && !settings.popup) {\n              module.refresh();\n            }\n\n            if ($popup && module.set.position()) {\n              module.save.conditions();\n\n              if (settings.exclusive) {\n                module.hideAll();\n              }\n\n              module.animate.show(callback);\n            }\n          }\n        },\n        hide: function hide(callback) {\n          callback = callback || function () {};\n\n          if (module.is.visible() || module.is.animating()) {\n            if (settings.onHide.call($popup, element) === false) {\n              module.debug('onHide callback returned false, cancelling popup animation');\n              return;\n            }\n\n            module.remove.visible();\n            module.unbind.close();\n            module.restore.conditions();\n            module.animate.hide(callback);\n          }\n        },\n        hideAll: function hideAll() {\n          $(selector.popup).filter('.' + className.popupVisible).each(function () {\n            $(this).data(metadata.activator).popup('hide');\n          });\n        },\n        exists: function exists() {\n          if (!$popup) {\n            return false;\n          }\n\n          if (settings.inline || settings.popup) {\n            return module.has.popup();\n          } else {\n            return $popup.closest($context).length >= 1 ? true : false;\n          }\n        },\n        removePopup: function removePopup() {\n          if (module.has.popup() && !settings.popup) {\n            module.debug('Removing popup', $popup);\n            $popup.remove();\n            $popup = undefined;\n            settings.onRemove.call($popup, element);\n          }\n        },\n        save: {\n          conditions: function conditions() {\n            module.cache = {\n              title: $module.attr('title')\n            };\n\n            if (module.cache.title) {\n              $module.removeAttr('title');\n            }\n\n            module.verbose('Saving original attributes', module.cache.title);\n          }\n        },\n        restore: {\n          conditions: function conditions() {\n            if (module.cache && module.cache.title) {\n              $module.attr('title', module.cache.title);\n              module.verbose('Restoring original attributes', module.cache.title);\n            }\n\n            return true;\n          }\n        },\n        supports: {\n          svg: function svg() {\n            return typeof SVGGraphicsElement === 'undefined';\n          }\n        },\n        animate: {\n          show: function show(callback) {\n            callback = $.isFunction(callback) ? callback : function () {};\n\n            if (settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {\n              module.set.visible();\n              $popup.transition({\n                animation: settings.transition + ' in',\n                queue: false,\n                debug: settings.debug,\n                verbose: settings.verbose,\n                duration: settings.duration,\n                onComplete: function onComplete() {\n                  module.bind.close();\n                  callback.call($popup, element);\n                  settings.onVisible.call($popup, element);\n                }\n              });\n            } else {\n              module.error(error.noTransition);\n            }\n          },\n          hide: function hide(callback) {\n            callback = $.isFunction(callback) ? callback : function () {};\n            module.debug('Hiding pop-up');\n\n            if (settings.onHide.call($popup, element) === false) {\n              module.debug('onHide callback returned false, cancelling popup animation');\n              return;\n            }\n\n            if (settings.transition && $.fn.transition !== undefined && $module.transition('is supported')) {\n              $popup.transition({\n                animation: settings.transition + ' out',\n                queue: false,\n                duration: settings.duration,\n                debug: settings.debug,\n                verbose: settings.verbose,\n                onComplete: function onComplete() {\n                  module.reset();\n                  callback.call($popup, element);\n                  settings.onHidden.call($popup, element);\n                }\n              });\n            } else {\n              module.error(error.noTransition);\n            }\n          }\n        },\n        change: {\n          content: function content(html) {\n            $popup.html(html);\n          }\n        },\n        get: {\n          html: function html() {\n            $module.removeData(metadata.html);\n            return $module.data(metadata.html) || settings.html;\n          },\n          title: function title() {\n            $module.removeData(metadata.title);\n            return $module.data(metadata.title) || settings.title;\n          },\n          content: function content() {\n            $module.removeData(metadata.content);\n            return $module.data(metadata.content) || settings.content || $module.attr('title');\n          },\n          variation: function variation() {\n            $module.removeData(metadata.variation);\n            return $module.data(metadata.variation) || settings.variation;\n          },\n          popup: function popup() {\n            return $popup;\n          },\n          popupOffset: function popupOffset() {\n            return $popup.offset();\n          },\n          calculations: function calculations() {\n            var $popupOffsetParent = module.get.offsetParent($popup),\n                targetElement = $target[0],\n                isWindow = $boundary[0] == window,\n                targetPosition = settings.inline || settings.popup && settings.movePopup ? $target.position() : $target.offset(),\n                screenPosition = isWindow ? {\n              top: 0,\n              left: 0\n            } : $boundary.offset(),\n                calculations = {},\n                scroll = isWindow ? {\n              top: $window.scrollTop(),\n              left: $window.scrollLeft()\n            } : {\n              top: 0,\n              left: 0\n            },\n                screen;\n            calculations = {\n              // element which is launching popup\n              target: {\n                element: $target[0],\n                width: $target.outerWidth(),\n                height: $target.outerHeight(),\n                top: targetPosition.top,\n                left: targetPosition.left,\n                margin: {}\n              },\n              // popup itself\n              popup: {\n                width: $popup.outerWidth(),\n                height: $popup.outerHeight()\n              },\n              // offset container (or 3d context)\n              parent: {\n                width: $offsetParent.outerWidth(),\n                height: $offsetParent.outerHeight()\n              },\n              // screen boundaries\n              screen: {\n                top: screenPosition.top,\n                left: screenPosition.left,\n                scroll: {\n                  top: scroll.top,\n                  left: scroll.left\n                },\n                width: $boundary.width(),\n                height: $boundary.height()\n              }\n            }; // if popup offset context is not same as target, then adjust calculations\n\n            if ($popupOffsetParent.get(0) !== $offsetParent.get(0)) {\n              var popupOffset = $popupOffsetParent.offset();\n              calculations.target.top -= popupOffset.top;\n              calculations.target.left -= popupOffset.left;\n              calculations.parent.width = $popupOffsetParent.outerWidth();\n              calculations.parent.height = $popupOffsetParent.outerHeight();\n            } // add in container calcs if fluid\n\n\n            if (settings.setFluidWidth && module.is.fluid()) {\n              calculations.container = {\n                width: $popup.parent().outerWidth()\n              };\n              calculations.popup.width = calculations.container.width;\n            } // add in margins if inline\n\n\n            calculations.target.margin.top = settings.inline ? parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-top'), 10) : 0;\n            calculations.target.margin.left = settings.inline ? module.is.rtl() ? parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-right'), 10) : parseInt(window.getComputedStyle(targetElement).getPropertyValue('margin-left'), 10) : 0; // calculate screen boundaries\n\n            screen = calculations.screen;\n            calculations.boundary = {\n              top: screen.top + screen.scroll.top,\n              bottom: screen.top + screen.scroll.top + screen.height,\n              left: screen.left + screen.scroll.left,\n              right: screen.left + screen.scroll.left + screen.width\n            };\n            return calculations;\n          },\n          id: function id() {\n            return _id;\n          },\n          startEvent: function startEvent() {\n            if (settings.on == 'hover') {\n              return 'mouseenter';\n            } else if (settings.on == 'focus') {\n              return 'focus';\n            }\n\n            return false;\n          },\n          scrollEvent: function scrollEvent() {\n            return 'scroll';\n          },\n          endEvent: function endEvent() {\n            if (settings.on == 'hover') {\n              return 'mouseleave';\n            } else if (settings.on == 'focus') {\n              return 'blur';\n            }\n\n            return false;\n          },\n          distanceFromBoundary: function distanceFromBoundary(offset, calculations) {\n            var distanceFromBoundary = {},\n                popup,\n                boundary;\n            calculations = calculations || module.get.calculations(); // shorthand\n\n            popup = calculations.popup;\n            boundary = calculations.boundary;\n\n            if (offset) {\n              distanceFromBoundary = {\n                top: offset.top - boundary.top,\n                left: offset.left - boundary.left,\n                right: boundary.right - (offset.left + popup.width),\n                bottom: boundary.bottom - (offset.top + popup.height)\n              };\n              module.verbose('Distance from boundaries determined', offset, distanceFromBoundary);\n            }\n\n            return distanceFromBoundary;\n          },\n          offsetParent: function offsetParent($element) {\n            var element = $element !== undefined ? $element[0] : $target[0],\n                parentNode = element.parentNode,\n                $node = $(parentNode);\n\n            if (parentNode) {\n              var is2D = $node.css('transform') === 'none',\n                  isStatic = $node.css('position') === 'static',\n                  isBody = $node.is('body');\n\n              while (parentNode && !isBody && isStatic && is2D) {\n                parentNode = parentNode.parentNode;\n                $node = $(parentNode);\n                is2D = $node.css('transform') === 'none';\n                isStatic = $node.css('position') === 'static';\n                isBody = $node.is('body');\n              }\n            }\n\n            return $node && $node.length > 0 ? $node : $();\n          },\n          positions: function positions() {\n            return {\n              'top left': false,\n              'top center': false,\n              'top right': false,\n              'bottom left': false,\n              'bottom center': false,\n              'bottom right': false,\n              'left center': false,\n              'right center': false\n            };\n          },\n          nextPosition: function nextPosition(position) {\n            var positions = position.split(' '),\n                verticalPosition = positions[0],\n                horizontalPosition = positions[1],\n                opposite = {\n              top: 'bottom',\n              bottom: 'top',\n              left: 'right',\n              right: 'left'\n            },\n                adjacent = {\n              left: 'center',\n              center: 'right',\n              right: 'left'\n            },\n                backup = {\n              'top left': 'top center',\n              'top center': 'top right',\n              'top right': 'right center',\n              'right center': 'bottom right',\n              'bottom right': 'bottom center',\n              'bottom center': 'bottom left',\n              'bottom left': 'left center',\n              'left center': 'top left'\n            },\n                adjacentsAvailable = verticalPosition == 'top' || verticalPosition == 'bottom',\n                oppositeTried = false,\n                adjacentTried = false,\n                nextPosition = false;\n\n            if (!triedPositions) {\n              module.verbose('All available positions available');\n              triedPositions = module.get.positions();\n            }\n\n            module.debug('Recording last position tried', position);\n            triedPositions[position] = true;\n\n            if (settings.prefer === 'opposite') {\n              nextPosition = [opposite[verticalPosition], horizontalPosition];\n              nextPosition = nextPosition.join(' ');\n              oppositeTried = triedPositions[nextPosition] === true;\n              module.debug('Trying opposite strategy', nextPosition);\n            }\n\n            if (settings.prefer === 'adjacent' && adjacentsAvailable) {\n              nextPosition = [verticalPosition, adjacent[horizontalPosition]];\n              nextPosition = nextPosition.join(' ');\n              adjacentTried = triedPositions[nextPosition] === true;\n              module.debug('Trying adjacent strategy', nextPosition);\n            }\n\n            if (adjacentTried || oppositeTried) {\n              module.debug('Using backup position', nextPosition);\n              nextPosition = backup[position];\n            }\n\n            return nextPosition;\n          }\n        },\n        set: {\n          position: function position(_position, calculations) {\n            // exit conditions\n            if ($target.length === 0 || $popup.length === 0) {\n              module.error(error.notFound);\n              return;\n            }\n\n            var offset, distanceAway, target, popup, parent, positioning, popupOffset, distanceFromBoundary;\n            calculations = calculations || module.get.calculations();\n            _position = _position || $module.data(metadata.position) || settings.position;\n            offset = $module.data(metadata.offset) || settings.offset;\n            distanceAway = settings.distanceAway; // shorthand\n\n            target = calculations.target;\n            popup = calculations.popup;\n            parent = calculations.parent;\n\n            if (module.should.centerArrow(calculations)) {\n              module.verbose('Adjusting offset to center arrow on small target element');\n\n              if (_position == 'top left' || _position == 'bottom left') {\n                offset += target.width / 2;\n                offset -= settings.arrowPixelsFromEdge;\n              }\n\n              if (_position == 'top right' || _position == 'bottom right') {\n                offset -= target.width / 2;\n                offset += settings.arrowPixelsFromEdge;\n              }\n            }\n\n            if (target.width === 0 && target.height === 0 && !module.is.svg(target.element)) {\n              module.debug('Popup target is hidden, no action taken');\n              return false;\n            }\n\n            if (settings.inline) {\n              module.debug('Adding margin to calculation', target.margin);\n\n              if (_position == 'left center' || _position == 'right center') {\n                offset += target.margin.top;\n                distanceAway += -target.margin.left;\n              } else if (_position == 'top left' || _position == 'top center' || _position == 'top right') {\n                offset += target.margin.left;\n                distanceAway -= target.margin.top;\n              } else {\n                offset += target.margin.left;\n                distanceAway += target.margin.top;\n              }\n            }\n\n            module.debug('Determining popup position from calculations', _position, calculations);\n\n            if (module.is.rtl()) {\n              _position = _position.replace(/left|right/g, function (match) {\n                return match == 'left' ? 'right' : 'left';\n              });\n              module.debug('RTL: Popup position updated', _position);\n            } // if last attempt use specified last resort position\n\n\n            if (searchDepth == settings.maxSearchDepth && typeof settings.lastResort === 'string') {\n              _position = settings.lastResort;\n            }\n\n            switch (_position) {\n              case 'top left':\n                positioning = {\n                  top: 'auto',\n                  bottom: parent.height - target.top + distanceAway,\n                  left: target.left + offset,\n                  right: 'auto'\n                };\n                break;\n\n              case 'top center':\n                positioning = {\n                  bottom: parent.height - target.top + distanceAway,\n                  left: target.left + target.width / 2 - popup.width / 2 + offset,\n                  top: 'auto',\n                  right: 'auto'\n                };\n                break;\n\n              case 'top right':\n                positioning = {\n                  bottom: parent.height - target.top + distanceAway,\n                  right: parent.width - target.left - target.width - offset,\n                  top: 'auto',\n                  left: 'auto'\n                };\n                break;\n\n              case 'left center':\n                positioning = {\n                  top: target.top + target.height / 2 - popup.height / 2 + offset,\n                  right: parent.width - target.left + distanceAway,\n                  left: 'auto',\n                  bottom: 'auto'\n                };\n                break;\n\n              case 'right center':\n                positioning = {\n                  top: target.top + target.height / 2 - popup.height / 2 + offset,\n                  left: target.left + target.width + distanceAway,\n                  bottom: 'auto',\n                  right: 'auto'\n                };\n                break;\n\n              case 'bottom left':\n                positioning = {\n                  top: target.top + target.height + distanceAway,\n                  left: target.left + offset,\n                  bottom: 'auto',\n                  right: 'auto'\n                };\n                break;\n\n              case 'bottom center':\n                positioning = {\n                  top: target.top + target.height + distanceAway,\n                  left: target.left + target.width / 2 - popup.width / 2 + offset,\n                  bottom: 'auto',\n                  right: 'auto'\n                };\n                break;\n\n              case 'bottom right':\n                positioning = {\n                  top: target.top + target.height + distanceAway,\n                  right: parent.width - target.left - target.width - offset,\n                  left: 'auto',\n                  bottom: 'auto'\n                };\n                break;\n            }\n\n            if (positioning === undefined) {\n              module.error(error.invalidPosition, _position);\n            }\n\n            module.debug('Calculated popup positioning values', positioning); // tentatively place on stage\n\n            $popup.css(positioning).removeClass(className.position).addClass(_position).addClass(className.loading);\n            popupOffset = module.get.popupOffset(); // see if any boundaries are surpassed with this tentative position\n\n            distanceFromBoundary = module.get.distanceFromBoundary(popupOffset, calculations);\n\n            if (module.is.offstage(distanceFromBoundary, _position)) {\n              module.debug('Position is outside viewport', _position);\n\n              if (searchDepth < settings.maxSearchDepth) {\n                searchDepth++;\n                _position = module.get.nextPosition(_position);\n                module.debug('Trying new position', _position);\n                return $popup ? module.set.position(_position, calculations) : false;\n              } else {\n                if (settings.lastResort) {\n                  module.debug('No position found, showing with last position');\n                } else {\n                  module.debug('Popup could not find a position to display', $popup);\n                  module.error(error.cannotPlace, element);\n                  module.remove.attempts();\n                  module.remove.loading();\n                  module.reset();\n                  settings.onUnplaceable.call($popup, element);\n                  return false;\n                }\n              }\n            }\n\n            module.debug('Position is on stage', _position);\n            module.remove.attempts();\n            module.remove.loading();\n\n            if (settings.setFluidWidth && module.is.fluid()) {\n              module.set.fluidWidth(calculations);\n            }\n\n            return true;\n          },\n          fluidWidth: function fluidWidth(calculations) {\n            calculations = calculations || module.get.calculations();\n            module.debug('Automatically setting element width to parent width', calculations.parent.width);\n            $popup.css('width', calculations.container.width);\n          },\n          variation: function variation(_variation) {\n            _variation = _variation || module.get.variation();\n\n            if (_variation && module.has.popup()) {\n              module.verbose('Adding variation to popup', _variation);\n              $popup.addClass(_variation);\n            }\n          },\n          visible: function visible() {\n            $module.addClass(className.visible);\n          }\n        },\n        remove: {\n          loading: function loading() {\n            $popup.removeClass(className.loading);\n          },\n          variation: function variation(_variation2) {\n            _variation2 = _variation2 || module.get.variation();\n\n            if (_variation2) {\n              module.verbose('Removing variation', _variation2);\n              $popup.removeClass(_variation2);\n            }\n          },\n          visible: function visible() {\n            $module.removeClass(className.visible);\n          },\n          attempts: function attempts() {\n            module.verbose('Resetting all searched positions');\n            searchDepth = 0;\n            triedPositions = false;\n          }\n        },\n        bind: {\n          events: function events() {\n            module.debug('Binding popup events to module');\n\n            if (settings.on == 'click') {\n              $module.on('click' + eventNamespace, module.toggle);\n            }\n\n            if (settings.on == 'hover' && hasTouch) {\n              $module.on('touchstart' + eventNamespace, module.event.touchstart);\n            }\n\n            if (module.get.startEvent()) {\n              $module.on(module.get.startEvent() + eventNamespace, module.event.start).on(module.get.endEvent() + eventNamespace, module.event.end);\n            }\n\n            if (settings.target) {\n              module.debug('Target set to element', $target);\n            }\n\n            $window.on('resize' + elementNamespace, module.event.resize);\n          },\n          popup: function popup() {\n            module.verbose('Allowing hover events on popup to prevent closing');\n\n            if ($popup && module.has.popup()) {\n              $popup.on('mouseenter' + eventNamespace, module.event.start).on('mouseleave' + eventNamespace, module.event.end);\n            }\n          },\n          close: function close() {\n            if (settings.hideOnScroll === true || settings.hideOnScroll == 'auto' && settings.on != 'click') {\n              module.bind.closeOnScroll();\n            }\n\n            if (module.is.closable()) {\n              module.bind.clickaway();\n            } else if (settings.on == 'hover' && openedWithTouch) {\n              module.bind.touchClose();\n            }\n          },\n          closeOnScroll: function closeOnScroll() {\n            module.verbose('Binding scroll close event to document');\n            $scrollContext.one(module.get.scrollEvent() + elementNamespace, module.event.hideGracefully);\n          },\n          touchClose: function touchClose() {\n            module.verbose('Binding popup touchclose event to document');\n            $document.on('touchstart' + elementNamespace, function (event) {\n              module.verbose('Touched away from popup');\n              module.event.hideGracefully.call(element, event);\n            });\n          },\n          clickaway: function clickaway() {\n            module.verbose('Binding popup close event to document');\n            $document.on('click' + elementNamespace, function (event) {\n              module.verbose('Clicked away from popup');\n              module.event.hideGracefully.call(element, event);\n            });\n          }\n        },\n        unbind: {\n          events: function events() {\n            $window.off(elementNamespace);\n            $module.off(eventNamespace);\n          },\n          close: function close() {\n            $document.off(elementNamespace);\n            $scrollContext.off(elementNamespace);\n          }\n        },\n        has: {\n          popup: function popup() {\n            return $popup && $popup.length > 0;\n          }\n        },\n        should: {\n          centerArrow: function centerArrow(calculations) {\n            return !module.is.basic() && calculations.target.width <= settings.arrowPixelsFromEdge * 2;\n          }\n        },\n        is: {\n          closable: function closable() {\n            if (settings.closable == 'auto') {\n              if (settings.on == 'hover') {\n                return false;\n              }\n\n              return true;\n            }\n\n            return settings.closable;\n          },\n          offstage: function offstage(distanceFromBoundary, position) {\n            var offstage = []; // return boundaries that have been surpassed\n\n            $.each(distanceFromBoundary, function (direction, distance) {\n              if (distance < -settings.jitter) {\n                module.debug('Position exceeds allowable distance from edge', direction, distance, position);\n                offstage.push(direction);\n              }\n            });\n\n            if (offstage.length > 0) {\n              return true;\n            } else {\n              return false;\n            }\n          },\n          svg: function svg(element) {\n            return module.supports.svg() && element instanceof SVGGraphicsElement;\n          },\n          basic: function basic() {\n            return $module.hasClass(className.basic);\n          },\n          active: function active() {\n            return $module.hasClass(className.active);\n          },\n          animating: function animating() {\n            return $popup !== undefined && $popup.hasClass(className.animating);\n          },\n          fluid: function fluid() {\n            return $popup !== undefined && $popup.hasClass(className.fluid);\n          },\n          visible: function visible() {\n            return $popup !== undefined && $popup.hasClass(className.popupVisible);\n          },\n          dropdown: function dropdown() {\n            return $module.hasClass(className.dropdown);\n          },\n          hidden: function hidden() {\n            return !module.is.visible();\n          },\n          rtl: function rtl() {\n            return $module.css('direction') == 'rtl';\n          }\n        },\n        reset: function reset() {\n          module.remove.visible();\n\n          if (settings.preserve) {\n            if ($.fn.transition !== undefined) {\n              $popup.transition('remove transition');\n            }\n          } else {\n            module.removePopup();\n          }\n        },\n        setting: function setting(name, value) {\n          if ($.isPlainObject(name)) {\n            $.extend(true, settings, name);\n          } else if (value !== undefined) {\n            settings[name] = value;\n          } else {\n            return settings[name];\n          }\n        },\n        internal: function internal(name, value) {\n          if ($.isPlainObject(name)) {\n            $.extend(true, module, name);\n          } else if (value !== undefined) {\n            module[name] = value;\n          } else {\n            return module[name];\n          }\n        },\n        debug: function debug() {\n          if (!settings.silent && settings.debug) {\n            if (settings.performance) {\n              module.performance.log(arguments);\n            } else {\n              module.debug = Function.prototype.bind.call(console.info, console, settings.name + ':');\n              module.debug.apply(console, arguments);\n            }\n          }\n        },\n        verbose: function verbose() {\n          if (!settings.silent && settings.verbose && settings.debug) {\n            if (settings.performance) {\n              module.performance.log(arguments);\n            } else {\n              module.verbose = Function.prototype.bind.call(console.info, console, settings.name + ':');\n              module.verbose.apply(console, arguments);\n            }\n          }\n        },\n        error: function error() {\n          if (!settings.silent) {\n            module.error = Function.prototype.bind.call(console.error, console, settings.name + ':');\n            module.error.apply(console, arguments);\n          }\n        },\n        performance: {\n          log: function log(message) {\n            var currentTime, executionTime, previousTime;\n\n            if (settings.performance) {\n              currentTime = new Date().getTime();\n              previousTime = time || currentTime;\n              executionTime = currentTime - previousTime;\n              time = currentTime;\n              performance.push({\n                'Name': message[0],\n                'Arguments': [].slice.call(message, 1) || '',\n                'Element': element,\n                'Execution Time': executionTime\n              });\n            }\n\n            clearTimeout(module.performance.timer);\n            module.performance.timer = setTimeout(module.performance.display, 500);\n          },\n          display: function display() {\n            var title = settings.name + ':',\n                totalTime = 0;\n            time = false;\n            clearTimeout(module.performance.timer);\n            $.each(performance, function (index, data) {\n              totalTime += data['Execution Time'];\n            });\n            title += ' ' + totalTime + 'ms';\n\n            if (moduleSelector) {\n              title += ' \\'' + moduleSelector + '\\'';\n            }\n\n            if ((console.group !== undefined || console.table !== undefined) && performance.length > 0) {\n              console.groupCollapsed(title);\n\n              if (console.table) {\n                console.table(performance);\n              } else {\n                $.each(performance, function (index, data) {\n                  console.log(data['Name'] + ': ' + data['Execution Time'] + 'ms');\n                });\n              }\n\n              console.groupEnd();\n            }\n\n            performance = [];\n          }\n        },\n        invoke: function invoke(query, passedArguments, context) {\n          var object = instance,\n              maxDepth,\n              found,\n              response;\n          passedArguments = passedArguments || queryArguments;\n          context = element || context;\n\n          if (typeof query == 'string' && object !== undefined) {\n            query = query.split(/[\\. ]/);\n            maxDepth = query.length - 1;\n            $.each(query, function (depth, value) {\n              var camelCaseValue = depth != maxDepth ? value + query[depth + 1].charAt(0).toUpperCase() + query[depth + 1].slice(1) : query;\n\n              if ($.isPlainObject(object[camelCaseValue]) && depth != maxDepth) {\n                object = object[camelCaseValue];\n              } else if (object[camelCaseValue] !== undefined) {\n                found = object[camelCaseValue];\n                return false;\n              } else if ($.isPlainObject(object[value]) && depth != maxDepth) {\n                object = object[value];\n              } else if (object[value] !== undefined) {\n                found = object[value];\n                return false;\n              } else {\n                return false;\n              }\n            });\n          }\n\n          if ($.isFunction(found)) {\n            response = found.apply(context, passedArguments);\n          } else if (found !== undefined) {\n            response = found;\n          }\n\n          if ($.isArray(returnedValue)) {\n            returnedValue.push(response);\n          } else if (returnedValue !== undefined) {\n            returnedValue = [returnedValue, response];\n          } else if (response !== undefined) {\n            returnedValue = response;\n          }\n\n          return found;\n        }\n      };\n\n      if (methodInvoked) {\n        if (instance === undefined) {\n          module.initialize();\n        }\n\n        module.invoke(query);\n      } else {\n        if (instance !== undefined) {\n          instance.invoke('destroy');\n        }\n\n        module.initialize();\n      }\n    });\n    return returnedValue !== undefined ? returnedValue : this;\n  };\n\n  $.fn.popup.settings = {\n    name: 'Popup',\n    // module settings\n    silent: false,\n    debug: false,\n    verbose: false,\n    performance: true,\n    namespace: 'popup',\n    // whether it should use dom mutation observers\n    observeChanges: true,\n    // callback only when element added to dom\n    onCreate: function onCreate() {},\n    // callback before element removed from dom\n    onRemove: function onRemove() {},\n    // callback before show animation\n    onShow: function onShow() {},\n    // callback after show animation\n    onVisible: function onVisible() {},\n    // callback before hide animation\n    onHide: function onHide() {},\n    // callback when popup cannot be positioned in visible screen\n    onUnplaceable: function onUnplaceable() {},\n    // callback after hide animation\n    onHidden: function onHidden() {},\n    // when to show popup\n    on: 'hover',\n    // element to use to determine if popup is out of boundary\n    boundary: window,\n    // whether to add touchstart events when using hover\n    addTouchEvents: true,\n    // default position relative to element\n    position: 'top left',\n    // name of variation to use\n    variation: '',\n    // whether popup should be moved to context\n    movePopup: true,\n    // element which popup should be relative to\n    target: false,\n    // jq selector or element that should be used as popup\n    popup: false,\n    // popup should remain inline next to activator\n    inline: false,\n    // popup should be removed from page on hide\n    preserve: false,\n    // popup should not close when being hovered on\n    hoverable: false,\n    // explicitly set content\n    content: false,\n    // explicitly set html\n    html: false,\n    // explicitly set title\n    title: false,\n    // whether automatically close on clickaway when on click\n    closable: true,\n    // automatically hide on scroll\n    hideOnScroll: 'auto',\n    // hide other popups on show\n    exclusive: false,\n    // context to attach popups\n    context: 'body',\n    // context for binding scroll events\n    scrollContext: window,\n    // position to prefer when calculating new position\n    prefer: 'opposite',\n    // specify position to appear even if it doesn't fit\n    lastResort: false,\n    // number of pixels from edge of popup to pointing arrow center (used from centering)\n    arrowPixelsFromEdge: 20,\n    // delay used to prevent accidental refiring of animations due to user error\n    delay: {\n      show: 50,\n      hide: 70\n    },\n    // whether fluid variation should assign width explicitly\n    setFluidWidth: true,\n    // transition settings\n    duration: 200,\n    transition: 'scale',\n    // distance away from activating element in px\n    distanceAway: 0,\n    // number of pixels an element is allowed to be \"offstage\" for a position to be chosen (allows for rounding)\n    jitter: 2,\n    // offset on aligning axis from calculated position\n    offset: 0,\n    // maximum times to look for a position before failing (9 positions total)\n    maxSearchDepth: 15,\n    error: {\n      invalidPosition: 'The position you specified is not a valid position',\n      cannotPlace: 'Popup does not fit within the boundaries of the viewport',\n      method: 'The method you called is not defined.',\n      noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',\n      notFound: 'The target or popup you specified does not exist on the page'\n    },\n    metadata: {\n      activator: 'activator',\n      content: 'content',\n      html: 'html',\n      offset: 'offset',\n      position: 'position',\n      title: 'title',\n      variation: 'variation'\n    },\n    className: {\n      active: 'active',\n      basic: 'basic',\n      animating: 'animating',\n      dropdown: 'dropdown',\n      fluid: 'fluid',\n      loading: 'loading',\n      popup: 'ui popup',\n      position: 'top left center bottom right',\n      visible: 'visible',\n      popupVisible: 'visible'\n    },\n    selector: {\n      popup: '.ui.popup'\n    },\n    templates: {\n      escape: function escape(string) {\n        var badChars = /[&<>\"'`]/g,\n            shouldEscape = /[&<>\"'`]/,\n            escape = {\n          \"&\": \"&amp;\",\n          \"<\": \"&lt;\",\n          \">\": \"&gt;\",\n          '\"': \"&quot;\",\n          \"'\": \"&#x27;\",\n          \"`\": \"&#x60;\"\n        },\n            escapedChar = function escapedChar(chr) {\n          return escape[chr];\n        };\n\n        if (shouldEscape.test(string)) {\n          return string.replace(badChars, escapedChar);\n        }\n\n        return string;\n      },\n      popup: function popup(text) {\n        var html = '',\n            escape = $.fn.popup.settings.templates.escape;\n\n        if (_typeof(text) !== undefined) {\n          if (_typeof(text.title) !== undefined && text.title) {\n            text.title = escape(text.title);\n            html += '<div class=\"header\">' + text.title + '</div>';\n          }\n\n          if (_typeof(text.content) !== undefined && text.content) {\n            text.content = escape(text.content);\n            html += '<div class=\"content\">' + text.content + '</div>';\n          }\n        }\n\n        return html;\n      }\n    }\n  };\n})(jQuery, window, document);","map":null,"metadata":{},"sourceType":"module"}